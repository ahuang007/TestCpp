--http://www.cnblogs.com/nepaul/archive/2011/08/18/2143936.html
--[[
语法：setmetatable (table, metatable)，对指定table设置metatable 【如果元表(metatable)中存在__metatable键值，setmetatable会失败】
语法：tmeta = getmetatable (tab)，返回对象的元表(metatable) 【如果元表(metatable)中存在__metatable键值，当返回__metatable的值】

算术类元方法:__add __mul __ sub __div __unm __mod __pow (__concat) 
关系类元方法:__eq __lt(<) __le(<=)，
其他Lua自动转换 a~=b --> not(a == b) a > b --> b < a a >= b --> b <= a 
----]]

local a = {
	x = 1,
	y = 10,
}

local b = {
	x = 3,
	y = 5,
}

local t = {}
t.__add = function(t1, t2)
	return t1.x + t2.x
end

t.__sub = function(t1, t2)
	return t1.y - t2.y
end
print(getmetatable(a)) -- nil
setmetatable(a, t)
print(getmetatable(a)) -- t的地址 
setmetatable(b, t)

print(a + b) -- 4 让两个表相加减 是不是【运算符重载】
print(a - b) -- 5

-- __index __newIndex 的用法

t.__index = {
	z = 5,
}
print(a.z, b.z) -- 5 5 当在a中找z这个key找不到 去它的元表t的__index中去找 
--查找元表的key __index 是不是相当于a【继承】t  于是 a拥有了t的属性

t.__newIndex = function(t, k, v)
	t.k = v
end

a.z = 6 -- a修改元表中key的值 调用__newIndex方法
--修改元表的key对应的value __newIndex 是不是相当于a【继承】t 于是a拥有了t的方法
print(a.z) -- 6

-----------------
--lua面向对象实现
-----------------

local _class={}
 
function class(super)
	local class_type={}
	class_type.ctor=false
	class_type.super=super
	class_type.new=function(...) 
		local obj={}
		do
			local create
			create = function(c,...)
				if c.super then
					create(c.super,...)
				end
				if c.ctor then
					c.ctor(obj,...)
				end
			end

			create(class_type,...)
		end
		setmetatable(obj,{ __index=_class[class_type] })
		return obj
	end
	local vtbl={}
	_class[class_type]=vtbl
 
	setmetatable(class_type,{__newindex=
		function(t,k,v)
			vtbl[k]=v
		end
	})
 
	if super then
		setmetatable(vtbl,{__index=
			function(t,k)
				local ret=_class[super][k]
				vtbl[k]=ret
				return ret
			end
		})
	end
 
	return class_type
end

-- 基类
base_type=class()		-- 定义一个基类 base_type
 
function base_type:ctor(x)	-- 定义 base_type 的构造函数
	print("base_type ctor")
	self.x=x
end
 
function base_type:print_x()	-- 定义一个成员函数 base_type:print_x
	print(self.x)
end
 
function base_type:hello()	-- 定义另一个成员函数 base_type:hello
	print("hello base_type")
end

-- 子类 

son_type=class(base_type)	-- 定义一个子类son_type  继承于 base_type
 
function son_type:ctor()	-- 定义 son_type 的构造函数
	print("son_type ctor")
end
 
function son_type:hello()	-- 重载 base_type:hello 为 son_type:hello
	print("hello son_type")
end

t=son_type.new(6) -- base_type ctor \n son_type ctor 
t:print_x() -- 6
t:hello() -- hello son_type


