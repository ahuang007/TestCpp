#第一讲

##c++的优势
c++能提升性能 性能意味着金钱
c++应用范围广泛

##c++包含的内容
a better c
支持数据抽象
支持面向对象(继承 封装 多态)
支持通用编程(泛型编程)

面向对象 = 对象 + 对象 + 消息
面向泛型 = 对象 + 对象 + 抽象行为

##c++支持的编程方式
过程式
数据抽象
基于对象
面向对象式
函数式
泛型形式
模板元形式 -- 某些运行时的工作提前到编译期 增加编译时间 提高运行效率

##c++11值得学习的几个特性
智能指针
右值引用
function/bind库 	-- 基于对象的编程 对继承缺陷的救赎
lambda表达式与闭包	-- 函数式编程

##推荐书籍
C++ primer(第四版或者第五版【c++11】)
Effective C++(第三版)
C++编码规范
敏捷软件开发--原型、模型与实践
代码大全(第二版)

#第二讲

##bool
true 逻辑真(非0)
false 逻辑假(0)
c语言中没有bool 用int替换

##const 
const 类型 变量名 = 常量;
常量必须在定义的时候初始化初始化
常量的值不能被更改

const int *p;
const 在*左边 表示*p为常量
经由*p不能更改指针所指的内容

int * const p = &a;
cosnt 在*右边 表示p为常量
必须在定义的时候初始化p，且p不能重新指向
但*p可以更改所指向的内容

###const与define区别
1 const有类型 define无类型
2 const分配内存 define不分配内存 只替换
3 作用域不同
注：undef可以取消掉define的值

##enum枚举常量
【c++推荐】 const enum inline 替换 define

结构体对齐
为什么要对齐？
性能原因 对齐访问速度快
如何对齐？
第一个结构体成员的地址和结构体地址相同
其他结构体成员的地址需要对应到某个对齐数的整数倍的地址上
对齐数：取编译器预设的一个对齐整数与该成员大小的较小值
结构体总大小为最大对齐数的整数倍

#pargma pack(4) 将编辑器对齐数设为4
#pargma pack()  取消掉自己设定的编辑器的对齐数
g++中对齐数只能设置成 1 2 4  vc中可以取值 1 2 4 8 16

#第三讲

##域运算符 ::
全局变量可以用::取值

##new delete运算符
new 在堆上分配空间 类似malloc
成功返回指针首地址 失败抛出异常
delete 释放分配的空间 类似free
堆上分配的空间程序自己销毁
new [] delete []

new一个对象
分配内存 
调用构造函数

new operator 分配内存 调用构造函数
operator new 只分配内存
placement new 不分配内存 仅仅调用拷贝构造函数

delete一个对象
释放内存
调用析构函数

##重载 
1 函数重载(静态的多态 编译时确定函数的入口地址 静态联编)
函数名相同 参数(个数 类型 顺序)不同
2 派生类虚函数(动态的多态 运行时确定函数的入口地址 动态联编)

name mangling 名字改编技术 实现函数重载
extern "C"
加上extern "C" 的函数不进行名字改编 
c语言不支持名字改编 因此也不支持函数重载

带默认参数的函数 

#第四讲

##引用
给一个变量起别名
引用不是变量 它仅仅是变量的别名
引用没有自己独立的空间 
与它所引用的变量共享空间
对引用所做的改变 也就是对引用的变量所做的改变
引用在定义的时候要进行初始化
引用一经初始化 不能再指向其他变量
引用一般作为参数传递和返回值

###const引用
指向const对象的引用
const引用不能够赋值
const引用可以指向普通变量
非const引用不能指向const常量

###引用作为参数传递
值传递
形参不能改变实参的值
指针传递
形参能改变实参的值
引用传递
形参能改变实参的值

###引用作为函数返回值
函数返回引用的作用 可以将函数放在赋值运算符的左边
引用在函数返回的时候初始化
不能返回局部变量的引用

###引用与指针的区别
引用直接访问 指针间接访问
引用是变量别名 不分配内存空间 
指针是变量 有地址空间的(32位系统4个字节) 保存的是他所指向的变量的地址
引用不能再赋值 指针可以
【c++推荐】尽量使用引用 不得已才用指针
如果是引用传递 实参初始化形参 不分配空间
如果是值传递 实参初始化形参 分配空间(如果是类对象 还要调用拷贝构造函数)
如果是指针传递 指针传递的本质还是值传递

#第五讲

##内联函数
用inline关键字修饰的函数
提高程序的执行效率
不涉及函数调用的开销 由编译器展开
什么时候用内联函数？
	函数体小
	函数调用频繁

###内联函数与带参数宏的区别
	内联函数进行类型检查	
	内联函数会对实参进行求值,然后传递给形参 宏只是简单的替换
	内联函数在编译期将函数展开 宏定义在预处理的时候展开

##宏
	1 常量			
	【c++高层次编程推荐】const enum
	2 带参数宏
	【c++高层次编程推荐】	inline

新的类型转换运算符
旧式转型
	(T)expr
	T(expr)
新的转型
	const_cast<T>(expr)
		用来移除对象的常量性 
		一般用于常量指针或者引用
		去除常量性不是为了修改所指向的内容 仅仅是为了函数能接受这个实际参数
	static_cast<T>(expr)
		编译器执行的任何隐式转换都可以用static_cast
		高精度的类型向低精度的类型转换的时候都能用static_cast
		可以将无类型指针转换成某一类型的指针
		可以将基类指针转成派生类指针
		无法将const转换成nonconst 只能由const_cast转换
	reinterpret_cast<T>(expr) 【慎用】
		为操作数的位模式提供较低层的重新解释 也就是说将数据以二进制的形式重新解释
	dynamic_cast<T>(expr)
		做一个向下的类型安全转换
		不能用旧式类型转换
隐式转换
	编译器可以自动完成的转换(安全)
显示转换
	类型转换运算符

【c++推荐】	
尽量避免使用强制类型转换
如果非要用 新式类型转换

#第六讲

##面向对象介绍(一)

###程序
作用：让计算机解决现实中的实际问题
用一定的数据来表示
按一定的逻辑来处理这些数据
程序 = 算法 + 数据结构
程序是完成一定功能的一系列有序指令的集合
指令 = 操作码 + 操作数
将指令按一定的顺序整合 就形成了程序

###语言
机器语言 
	更多的要站在机器的角度考虑问题
	而不是从解决问题的本身空间中考虑问题
	现实世界中的数据 我们不得不用二进制来表示
	要施加的逻辑也不得不用二进制指令来表示
	要按照机器的思维来解决问题(思维被束缚)
汇编语言
	将机器指令映射为可以被人读懂的助记符(ADD,SUB...)
	抽象层次比较低 大部分的时候还是需要以机器的思维来考虑问题
高级语言
	屏蔽了机器的细节 提高了语言的抽象层次
	使得现实中的一些事物与程序联系起来

##结构化程序设计
	机器与汇编 代码与数据界限模糊
	程序 = 算法 + 数据结构
	思想: 	自顶向下 逐步细分
			将程序视为分层的子程序集合
			可以将程序分为功能不同的模块,使得整个程序更有条理
			但是很多数据都属于整个程序 因而还是需要很多的全局变量
			对某个地方的修改 可能会对整个程序产生难以预料的影响
	要求一个软件负责人了解整个系统的任务分解
	当问题复杂度超过了个人能够理解的各子程序之间的调用关系的时候，这种自顶向下的思想可能失效 从来出现软件危机
	不适合大型软件的开发
	
##面向对象程序设计
	程序 = 对象 + 对象 + 发送消息
	对象 = 算法 + 数据

	封装
	继承
	多态

#第七讲

##面向对象程序设计
对象:只要暴露的接口稳定 内部发生变化 在外界看来 是没有变化的

结构化程序设计：过程抽象(以算法为中心)
面向对象程序设计: 数据抽象(以对象为中心)

对象在计算机中是一块内存 包括数据和方法 这些数据只能用自己内部的方法去操作

###抽象
认识事物的基本方法 抓住事物本质 而不是具体的细节和具体的实现 从具体到一般的过程(归类的思想)
将现实事物中实体抽象形成类的概念
对象->类(归类的思想)
大类->小类(分类的思想)

###封装
使用者更加专注 不用关心内部是怎么工作的
封装是对我们更好的服务

###继承
表达了对象 一般与特殊的关系 
从一般到特殊 分类的思想
从特殊到一般 归类的思想

利用现有的类构造新的类(拿来主义)
从而提高了程序的复用性

###多态
同一消息被不同对象调用时 产生不同的结果
多态使得我们能用一致的观点来看待不同的（但又大相径庭）的对象
同一个消息发送到不同的对象就会得到不同的行为

继承和多态的组合 可以生产相似但又独一无二的对象

面向对象开闭原则：对增加开放 对修改关闭
使用该对象的原有系统就不会发生改变

##面向对象基本原则：
1 单一职责原则(Single Responsibility Principle SRP)
一个类只负责一个职责，只有一个引起变化的原因.

2 里氏替换原则(Liskov Substitution Principle LSP)
任何基类可以出现的地方，子类一定可以出现.

3 依赖倒置原则(Dependence Inversion Principle DIP)
要依赖于抽象，不要依赖于具体

4 迪米特法则 最少知识原则(Least Knowledge Principle LKP)
说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。

5 开放封闭原则(Open-Closed Principle OCP)
软件实体应该对扩展开发，而对修改封闭。

6 接口隔离原则(Interface Segregation Principle ISP)
使用多个专门的接口比使用单一的总接口要好

7 组合/聚集复用原则(Composite/Aggregate Reuse Principle CARP)
尽量使用合成/聚合，而不是使用继承。

###面向对象优点：
易维护
质量高
效率高
易扩展（高类聚低耦合）

###面向对象缺点:
运行效率会比c低一些

#第八讲

类声明 

class 类名称
{
public:
	公有成员
private:
	私有成员
protected:
	保护成员
};

公有,私有,保护成员
公有 外部可以访问
私有 只有内部可以访问
保护 在派生类的成员函数可以访问

数据抽象和封装
数据抽象 依赖于接口和实现分离的编程
类的设计者 类的实现
类的使用者 类的接口
	       类的使用者不需要关注类内部是怎么实现，也不需要关注类内部所采用的数据 
	       他只需要关注这个类能提供什么功能。
	       只要这个类所提供的功能不变,也就是类所暴漏的接口稳定，
	       那么对类使用者所编写的代码的代码就是稳定的

封装
并非给客户越多的东西就是越好的服务
相反，仅仅给他需要关注的东西才是最好的服务
这样子能防止粗心的程序员破坏类内部的数据结构

第九讲

内联成员函数
内联函数能够提高运行效率 编译时将代码直接嵌入调用的地方 从而减少了函数调用的开销
程序的体积会增大(以空间换时间)
内联函数紧紧只是给编译器一个提示 如果函数中有switch,for等 或者代码长度比较长 编译器可能不会将它作为内联函数来编译

内联函数
1 直接在类体中给出实现代码
2 在实现的前面加上inline关键字

成员函数的重载及其缺省函数
参数类型或者个数不同
参数可以有默认值
当一个函数有缺省值的时候 另一个函数正好缺这个参数 会出现函数调用的二义性

类与结构体
c++中的结构体可以有成员函数
默认情况下的属性 类是私有的 结构体是公有的

隐含的this指针

类的内存模型
成员函数是只读的代码 由所有对象共享(一份)
数据成员 每个对象初始化一份内存(多份)

每个函数默认的第一个参数为this指针 this指针是指向该对象自身的指针 可以省略掉

第十讲

类作用域

文件作用域		从定义到文件结束有效
块作用域 		在{}之间有效
函数作用域		在函数内部有效(仅仅针对goto语句 label在后面定义 但可以在前面使用 goto label)
函数原型作用域	函数声明的参数名仅在函数()之间有效 也可省略
类作用域		每个类都定义了自己的作用域 类作用域中说明的标识符仅在类中可见

前向声明

c++中类必须先定义 才能实例化
两个类需要相互引用形成一个"环形"引用(a包含b b包含a)时,无法先定义使用，这时需要用到前向声明
前向声明的类不能实例化(定义对象) 只能定义指针或者引用

嵌套类
class Outer
{
	class Inner
	{
	public:
		void Fun()
		{
			cout<<"Inner::Fun"<<endl;
		}
	};

public:	
	Inner in;
	void Fun()
	{
		cout<<"Outer::Fun"<<endl;
		in.Fun();
	}
};

外围类需要使用嵌套类对象作为底层实现，并且该嵌套类只用于外围类的实现，且同时可以对用户隐藏该底层实现
嵌套类的成员函数可以在类体外定义 void Outer::Inner::Fun();
嵌套类的成员函数对外围类的私有成员没有访问，外围类的成员函数也不能访问嵌套类的私有成员

局部类

定义在函数体内的类
局部类只在定义它的局部域内可见
局部类的成员函数必须定义在类体中
局部类中不能有静态成员

第十一讲
 
构造函数与析构函数

构造函数是特殊的成员函数
创建类类型的新对象 系统会自动调用构造函数
构造函数是为了让每个数据成员都能被正确初始化

构造函数:
1 名称和类名相同
2 不能有返回类型
3 构造函数通常声明为公有的
//构造函数声明为私有的有特殊用途
4 构造函数可以重载(参数类型,参数个数不同)

不带参数的构造函数称为默认构造函数
如果类不提供任何一个构造函数 系统将为类提供一个不带参数的默认的构造函数
如果类提供了一个构造函数 系统将不在为类提供一个默认的构造函数

new运算符 不仅分配内存 还调用了构造函数
delete运算符 不仅释放内存 还调用析构函数

析构函数不能够被重载(没有参数)
默认情况下 先构造的对象后析构

全局对象 比main函数先构造

析构函数:
函数名和类名相似(前面多了~)
没有参数和返回值
类不提供析构函数，编译器会提供一个默认的析构函数

new	<=>	 delete 
new [] <=> delete []
堆上创建的对象 要在程序中主动调用delete【同时会调用析构函数】 释放该对象
栈上创建的对象 在生命期结束的时候自动释放该对象

构造函数一般不能显式调用 析构函数能显式掉用,但一般很少用(stl代码中有用到)

第十二讲

转换构造函数
单个参数的构造函数
(转换构造函数一定是单个参数的构造函数 但是单个参数的构造函数不一定是转换构造函数)
将其他类型转换为类类型

构造函数作用:
1 初始化	(所有构造函数都有)
2 类型转换	(转换构造函数特有)

赋值与初始化区别

Test t = 10; 等价于 Test t(10);
这里的"="不是运算符 是初始化

t = 20; //赋值运算符

等号运算符
Test& operator=(const Test& other);
如果不提供等号运算符 系统默认会有一个等号运算符 做的也是数据成员的逐个赋值

拷贝构造函数
1 判断是否等于
2 分配内存
3 赋值操作
4 返回这个对象的地址

赋值运算符
1 判断是否等于
2 赋值操作
3 返回这个对象的地址

Test t2;
t2 = t; // 赋值操作 t2.operator=(t);

explicit关键字
表示只能显示构造对象 不能够隐式构造对象
如果要阻止编译器的隐式转换 可以使用该参数

第十三讲

构造函数初始化列表 
【推荐】数据成员的初始化放在初始化列表中
构造函数的执行分两个阶段:
初始化段(初始化)
普通计算段(赋值)

对象成员及其初始化
对象成员的初始化在对象初始化之前
如果对象成员的类无默认构造函数 其初始化【只能】放在初始化列表中
对象成员的初始化顺序与在初始化列表中的顺序无关，只与对象在类中的定义的顺序有关

const成员,引用成员初始化

const成员的初始化【只能】在构造函数列表中
引用成员的初始化【只能】放在构造函数的列表中

枚举

类中的const常量对这个对象来说是常量 但不是对所有对象来说是常量
如果要对所有对象是常量 可以用到enum常量
class A
{
public:
	enum E_TYPE
	{
		TPYE_A = 100,
		TYPE_B = 200
	};
};

TYPE_A和TYPE_B对所有类的对象来说都是常量


第十四讲

拷贝构造函数
功能：用一个已经存在的对象初始化一个新的同一类型的对象
声明：只有一个参数且参数为该类对象的引用
如果类中没有声明拷贝构造函数，则系统会生成一个缺省拷贝构造函数，作为该类的公有成员

拷贝构造函数调用的几种情况

1 当函数的形参是类对象，调用函数时，进行形参与实参结合时使用
	用引用进行传递可以减少内存的复制 对象的拷贝 从而提高效率
2 当函数的返回值是类对象，函数执行完成返回调用者时使用

第十五讲

深拷贝与浅拷贝
系统默认提供的拷贝构造函数是浅拷贝 
如果类中有动态内存分配 (不共享内存)需要自己写拷贝构造函数实现深拷贝
*如果需要共享内存 在析构函数中处理 看这一块内存的引用计数是否为0 如果为0 则将这块内存释放掉

赋值操作
系统默认提供的赋值运算符函数也是浅拷贝 
如果类中有动态内存分配 (不共享内存)需要自己写赋值运算符函数实现深拷贝

禁止拷贝
读一无二的对象禁止拷贝(单例)
将拷贝构造函数和赋值运算符函数声明为私有函数 且不提供其实现

空类默认产生的成员

空类的大小 1个字节

class Empty {};					
Empty();						//默认构造函数
~Empty();						//默认析构函数
Empty(const Empty& e);			//默认拷贝构造函数
Empty& operator=(const Empty& e);		//默认赋值运算符
Empty* operator&();				//取地址运算符
const Empty* operator&() const;	//取地址运算符const

Empty* Empty::operator&()
{
	return this;
}

Empty e;
Empty* p = &e; //等价于 e.operator&();

const Empty* Empty::operator&() const
{
	return this;
}

const Empty e;
const Empty* p = &e; //等价于 e.operator&()const;


第十六讲

static成员
该类型的所有对象都共享
如果用全局变量会破坏数据的封装性(static成员只有该类的对象能操作 全局变量所有地方都能修改)
非static数据成员存在于类类型的每个对象中
static数据成员独立该类的任意对象存在，它是与类关联的对象，不与类对象关联

需要在类定义体外初始化与定义 在类体里面进行引用行声明
static const int 成员可以在类体内初始化与定义(char也可以  但是其他类型不可以)

static成员函数
static成员函数没有this指针
所以它不可以访问非静态成员和非静态成员函数
非静态成员函数可以访问静态成员

类/对象大小计算
空类大小为1个字节
遵循结构体对齐原则
类大小与数据成员有关 与成员函数有关
类大小与静态成员无关
虚函数对类大小的影响
	有一个或者多个虚函数 就增加4个字节的空间(指向虚表的指针)
虚继承对类大小的影响


第十七讲

变量的作用域与生存期不总是等同的
四种对象的作用域与生存期:

栈
栈上创建的对象在作用域结束就自动调用析构函数释放内存

堆
堆上创建的对象即时跳出作用域也不能自动释放，需要显示释放内存

全局对象,静态全局对象
全局对象和静态全局对象的构造先于main函数
已初始化的全局变量或静态对象  存储于.data段中
未初始化的全局变量或者静态对象(初始值为0) 存储于.bss(block started by symbol)段中【不需要分配内存,只用标号就行】

局部静态对象
普通静态变量在编译器初始化 
类对象静态变量在运行期初始化

static用法总结：
【c语言】
1 用于函数内部修饰变量 这种变量的生存期长期该函数
这种函数为不可重入函数 也不是线程安全的函数
这种函数不能用在信号处理函数中

2 用在文件级别 函数体之外 
两个文件中都可以声明 static int a = 100; 是两个不同的变量
如果一个文件要用另一个文件的全局变量 需要用到extern关键字(在外部进行声明)

【c++】
3 修饰类的数据成员(静态数据成员) 
生存期大于类对象 类数据成员【静态数据成员对所有的类只有一份内存 非静态数据成员每个类一份内存】

4 修饰类的成员函数
无this指针 不能访问类的非static成员 只能访问该类的静态成员 类成员函数


第十八讲

static与单例模式

单例模式
设计模式的一种
保证一个类只有一个实例，并提供一个全局访问点
禁止拷贝

实现方法:
将构造函数声明为私有的
将拷贝构造函数声明为私有的
将赋值运算符函数声明为私有的

需要提供一个全局的访问函数GetInstance()

单例模式析构函数

1 手动调用函数释放
2 嵌套类成员析构时释放
3 auto_ptr 智能指针
4 静态局部变量 生命期和这个类相同 //这个方法不是线程安全的单例模式类


第十九讲

const成员函数
不会修改对象的状态
只能访问数据成员的值而不能修改它
一个成员函数不修改对象的状态 应尽量用const关键字修饰该函数
const成员函数和非const成员函数可以构成重载

const对象
const对象不能调用非const成员函数(存在对对象修改的风险) 
他只能调用const成员函数

mutable关键字
用mutable关键字修饰的数据成员即使在const对象或const成员函数中都可以修改

const用法总结：


1 const常量 定义常量(常量对象) 必须初始化
const int a = 3;
const Test t(10);

2 const引用 引用自一个const常量 普通引用不能引用const常量
const Test& t1 = t;

3 const修饰指针 
const int *p; 		//【指向常量的指针】表示 *p(指针所指向的内容)是常量
int * const p; 		//【常量指针】表示 p(指针本身)是常量 p不能指向其他变量
const int * const p;//【指向常量的常量指针】表示p(指针本身)是常量 *p(指针指向的内容)也是常量
const成员的初始化必须在初始化列表初始化

4 const修饰成员函数
表示该成员函数不能修改对象状态


第二十讲

用c的方式实现栈

struct CLinkNode
{
	int data;
	struct CLinkNode* next;
};

struct CStack
{
	struct CLinkNode * head;
	int size;
};

用c++数据抽象的方式实现栈

结构体也是类
NULL 
c等价于 (void*)0 
c++等价于 0

class MyStack
{
	//结构体也是类
	struct Node
	{
		int m_data;
		struct Node* m_next;
		Node(int data, struct Node* next):m_data(data), m_next(next);
	};
public:
	MyStack():m_head(0), m_size(0);
	~MyStack();
	void Push(const int data);
	bool Pop(int& data);
	bool IsEmpty() const;
	void Traverse() const;
private:
	Node* m_head;
	int m_size;
};

c++与c的区别
1 初始化不用手动调用函数(调用构造函数)
2 调用函数方便(成员函数有this指针)
3 避免名称冲突(类内部可见)
4 类型的扩充
5 数据的封装 能保护内部的数据结构不被修改
6 内部结构修改 只要函数名不修改 对外部来说是一样的
7 c++多用引用 c多用指针


第二十一讲

友元介绍
友元是一种非类成员函数能访问类的非公有成员函数的机制
可以把一个函数指定为一个类的友元(友元函数) 
也可以把一个类指定为另一个类的友元(友元类)

友元函数
在类作用域外定义 在类体中说明
friend 类型 函数名(参数表);
破坏了类的封装性
提高程序的运行效率(减少访问非公有成员函数调用开销)

友元函数注意事项:
不是类的成员函数 直接通过友元函数名来访问 类成员函数是通过类对象来访问
不受类中访问权限关键字的限制(放在public,private下面都一样)
不是类的作用域
破坏了类的封装 如果不是必须 应尽可能的少用

友元类
将一个类声明为另一个类的友元
friend class 类名;

友元类注意事项:
友元关系是单向的
	A类是B类的友元类 B类不是A类的友元类
友元关系不能传递
	A是B的友元类 B是C的友元类 A不是C的友元类
友元关系不能派生
	A是B的友元类 C继承自A  C不是B的友元类


第二十二讲

运算符重载
允许将标准运算符运用于自定义数据类型
本质上时函数调用
直观自然 提高可读性
体现了c++的可扩展性

成员函数重载
Test& operator+(const Test& other)
返回*this

非成员函数重载
以友元函数的方式重载
friend Test& operator+(const Test& t1, const Test& t2);
返回 新建一个对象t3 返回这个对象的引用
不是类的成员函数，没有this指针 所以第一个参数是类对象本身
在类体外定义

运算符重载规则

不允许发明新的运算符
不能改变运算符操作对象的个数
运算符重载不会改变优先级和结合性
部分不能重载的运算符(:: ?: . .* sizeof)

单目运算符重载为类的成员函数
双目运算符重载为类的友元函数(其中 =, (), [], -> 不能重载为类的友元函数，只能重载为成员函数)
类型转换运算符只能以成员函数方式重载
流运算符只能以友元方式重载


第二十三讲

++运算符重载【推荐用成员函数的方式重载】
前置++
Test& operator++();
后置++(利用临时变量)
const Test operator++(int);
后置运算符比前置运算符多一个参数 用来重载

！运算符重载
bool operator!(String& str) const
{
	return strlen(str.m_str) == 0;
}

赋值运算符重载
MyString str = "1111";
//(重载前) 1 调用转换构造函数 2 调用赋值运算符
字符串类重载2个赋值运算符
MyString& operator=(const MyString& other);//赋值运算符函数（对象）
MyString& operator=(const char* str);//赋值运算符函数（字符串）

第二十四讲

[]运算符重载【成员函数】
返回引用可以出现在=运算符的左边
如果是const对象 则不能赋值 需要重载一个const的[]运算符
char& operator[](unsigned int index)
{
	return const_cast<char&>(static_cast<const MyString&>(*this)[index]);
}
const char& operator[](unsigned int index) const
{
	reurn m_str[index];
}
nonconst版本调用const版本(用强制类型转换)


二元运算符推荐用友元的方式重载
+运算符重载【友元】
friend MyString operator+(const MyString& str1, const MyString& str2);

+=运算符重载【成员函数】
MyString& operator+=(const MyString& str);

流操作 用友元的方式重载 <<s1<<s2<<s3;
第一个参数必须是流对象
返回值必须是流对象引用
<<运算符重载(cout是ostream的一个对象)
friend ostream & operator <<(ostream &os,const MyString& d);

>>运算符重载(cin是istream的一个对象)
friend istream & operator >>(istream &is, MyString& d);


第二十五讲

类型转换运算符重载
必须是成员函数 不能是友元函数
没有参数(类自身)
不能指定返回值(需要转换的类型)
函数原型 operator 类型名();

指针运算符 
利用类对象的确定性析构实现智能指针
使用智能指针避免内存泄露
函数原型  Test* operator->();

operator new
三种用法:
new operator
等价于 operator new + 构造函数的调用
operator new
分配内存
placement new
在已经存在的内存上构造对象
char tmp[10];
Test* t = new(tmp) Test(); //这里new不分配内存 就在tmp内存上构造对象

operator delete 释放内存
不能带参数 

__FILE__ 代码文件名(带绝对路径的)
__LINE__ 代码文件行号
